const Path = require('path');

/*

Attempted to use: 

  command-line-args ^5.1.1: 
    no validation, no --

   commander ^6.2.0:
     
*/
class Options {

  constructor(options) {
    this._shortOptions = {};
    this._longOptions = {};
    for (const [name, value] of Object.entries(options.options)) {
      const optInfo = Object.assign({ name, long: name, }, value);
      this._longOptions[optInfo.long] =  optInfo;
      if (optInfo.short) this._shortOptions[optInfo.short] =  optInfo;
    }
  }

  

  parse(args=process.argv.slice(2)) {
    const errors = [];
    const options = {};
    const restArgs = [];
    const lastIndex = args.indexOf('--');
    const nonOptArgs = [];
    if (lastIndex >= 0) {
      nonOptArgs.push(...args.slice(lastIndex + 1));
      args = args.slice(0, lastIndex);
    }
    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      if (arg.startsWith('--')) {
	i += this._longOption(args, i, options, errors);
      }
      else if (arg.startsWith('-')) {
	i += this._shortOption(args, i, options, errors);
      }
      else {
	restArgs.push(arg);
      } 
    }
    this.options = options; this.errors = errors;
    restArgs.push(...nonOptArgs); this.restArgs = restArgs;
  }

  _longOption(args, i, options, errors) {
    let nExtraArgs = 0;
    const arg = args[i].slice(2);
    const eqIndex = arg.indexOf('=');
    const option = (eqIndex >= 0) ? arg.slice(0, eqIndex) : arg;
    const optionInfo = this._longOptions[option];
    if (!optionInfo) {
      errors.push({ code: 'UNKNOWN', option,
		    message: `unknown option '${option}' in '${args[i]}'`,
		  });
      return 0;
    }
    else {
      const value = (eqIndex >= 0) ? arg.slice(eqIndex + 1) : null;
      return this._optionValue(args, i, '--' + option, value, optionInfo,
			       options, errors);
    }
  }

  _shortOption(args, i, options, errors) {
    const arg = args[i].slice(1);
    for (let j = 0; j < arg.length; j++) {
      const option = arg[j];
      const optionInfo = this._shortOptions[option];
      if (!optionInfo) {
	errors.push({ code: 'UNKNOWN', option,
		      message: `unknown option '-${option}' in '${args[i]}'`,
		    });
      }
      else if (!optionInfo.type) {
	options[optionInfo.name] = true;
      }
      else {
	const value = (j < arg.length - 1) ? arg.slice(j + 1) : null;
	return this._optionValue(args, i, '-' + option, value, optionInfo,
				 options, errors);
      }
    }
    return 0;
  }


  _optionValue(args, i, option, value, optionInfo, options, errors) {
    let nExtraArgs = 0;
    const { name } = optionInfo;
    let error = null;
    if (value === null) {
      if (!optionInfo.type) {
	value = true;
      }
      else if (optionInfo.isOptional) {
	value = (optionInfo.type === Boolean) ? true : '';
      }
      else if (i < args.length - 1) {
	value = optionInfo.type(args[i + 1]);
	nExtraArgs = 1;
      }
      else {
	error = { code: 'MISSING_VALUE',  name,
		  message: `missing value for option '${option}'`
		};
      }
    } //if (value === null)
    else if (!optionInfo.type) {
	error = { code: 'EXTRA_VALUE', name,
		  message: `option ${option} does not take a value`,
		};
    }
    if (!error && optionInfo.type) {
      try {
	value = optionInfo.type(value);
      }
      catch (err) {
	error = { code: 'BAD_VALUE', name,
		  message: `bad value ${value} for option ${option}`,
		};
      }
    }
    if (error) {
      errors.push(error);
    }
    else if (optionInfo.isRepeat) {
      if (!options[name]) options[name] = [];
      options[name].push(value);
    }
    else {
      options[name] = value;
    }
    return nExtraArgs;
  }
    
  summary() {
    let text = '';
    const arg = this.arg ? ` ${this.arg}` : '';
    if (this.shortOpt) text += `-${this.shortOpt}${arg}`;
    if (this.shortOpt && this.longOpt) text += ' | ';
    if (this.longOpt) text += `--${this.longOpt}${arg}`;
    return text;
  }

  help() {
    let text = ' '.repeat(INDENT) + this.summary();
    if (this.doc) {
      text += '\n' + ' '.repeat(INDENT*2) + this.doc;
    }
    return text;
  }
}

const OPTIONS = {
  'eval': {
    short: 'e',
    argLabel: 'SCRIPT',
    type: String,
    isRepeat: true,
    doc: `
      JS code to run; SCRIPT labelled BEGIN, END run only at begin/end
    `.trim(),
  },
  inPlace: {
    long: 'in-place',
    short: 'i',
    isOptional: true,
    type: String,
    argLabel: '[EXT]',
    doc: 'replace input file; if EXT, then backup with EXT',
  },
  loop: {
    short: 'l',
    doc: 'loop over "lines" of FILES, setting _ to each line',
  },
  print: {
    short: 'p',
    doc: 'print _ after each loop iteration',
  },
  sep: {
    short: 's',
    argLabel: 'STRING|REGEX',
    type: String,
    help: '_ lines automatically split into $1, $2, ... using STRING|REGEX',
  }, 
};
const options = new Options({options: OPTIONS});
options.parse();
console.log(options.options, options.restArgs, options.errors);


module.exports = { Options };

